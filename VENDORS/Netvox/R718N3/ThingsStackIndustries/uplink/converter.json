{
  "name": "Netvox R718N3 Uplink for ThingsStackIndustries integration",
  "type": "UPLINK",
  "debugMode": true,
  "configuration": {
    "scriptLang": "TBEL",
    "decoder": null,
    "tbelDecoder": "var data = decodeToJson(payload);\n\nvar deviceName = data.end_device_ids.device_id;\nvar deviceType = data.end_device_ids.application_ids.application_id;\nvar groupName = 'IAQ devices';\n// var customerName = 'Customer A';\n// use assetName and assetType instead of deviceName and deviceType\n// to automatically create assets instead of devices.\n// var assetName = 'Asset A';\n// var assetType = 'building';\n\n// If you want to parse incoming data somehow, you can add your code to this function.\n// input: bytes\n// expected output:\n//  {\n//    \"attributes\": {\"attributeKey\": \"attributeValue\"},\n//    \"telemetry\": {\"telemetryKey\": \"telemetryValue\"}\n//  }\n//\n// In the example - bytes will be saved as HEX string and also parsed as light level, battery level and PIR sensor value.\n//\n\nfunction decodeFrmPayload(input) {\n  var output = { attributes:{}, telemetry: {} };\n  // --- Decoding code --- //\n  //  output.telemetry.f12 = 4;\n  var fPort = input.get(\"f_port\");\n\n  if (fPort != null && fPort === 6) {\n      var frmPayloadBytes = base64ToBytes(input.get(\"frm_payload\"));\n      reportDataCmd(byteArrayToExecutionArrayList(frmPayloadBytes), output);\n  } else {\n      raiseError(\"Data decoding error. The 'f_port' = \" + fPort + \", f_port must be: 6\");\n  }\n  return output;\n}\n\n\nfunction reportDataCmd(frmPayload, output) {\n  var i = 0;\n  while (i < (frmPayload.length - 3)) {\n    var version = frmPayload[i++] & 0xff;\n    var deviceTypeId = frmPayload[i++] & 0xff;\n    var reportType = frmPayload[i++] & 0xff;\n    if (i < (frmPayload.length - 7) && version === 0x01 && deviceTypeId === 0x4A) {\n      switch (reportType) {\n        case 0:\n          reportDataCmdPort6Type0(frmPayload.slice(i, i + 8), output);\n          i +=8;\n          break;\n        case 1:\n          var len = 8;\n          if (i < (frmPayload.length - 18) && (frmPayload[i + 8] & 0xff) ===  0x01\n              && (frmPayload[i + 9] & 0xff) === 0x4A && (frmPayload[i + 10] & 0xff) === 2) {\n            len = 19;\n          }\n          reportDataCmdPort6Type1_2(frmPayload.slice(i, i + len), output);\n          i +=len;\n          break;\n        case 3:\n          reportDataCmdPort6Type3(frmPayload.slice(i, i + 8), output);\n          i +=8;\n          break;\n        case 4:\n          reportDataCmdPort6Type4(frmPayload.slice(i, i + 8), output);\n          i +=8;\n          break;\n        default:\n\n      }\n    }\n  }\n  if (output.?telemetry.size() === 0 && output.?attributes.size() === 0) {\n    output.telemetry.frm_payload_result = \"isEmpty\";\n  }\n}\n\nfunction reportDataCmdPort6Type0(data, output) {\n  var softwareVersion = parseBytesIntToFloat(data, 0, 1)/10;\n  var hardwareVersion = data[1];\n  var dateCodeStr = bytesToHex(data.slice(2, 4));\n  output.attributes.SWver = softwareVersion;\n  output.attributes.SWverSt = \"V\" + softwareVersion;\n  output.attributes.HWver = hardwareVersion;\n  output.attributes.Datecode = dateCodeStr;\n\n}\n\nfunction reportDataCmdPort6Type1_2(data, output) {\n  var current = reportDataCmdPort6CurrentVolt(data, output);\n  var multiplier1;\n  if (data.length === 8) {\n    multiplier1 = parseBytesToInt(data.slice(7));\n    output.telemetry.Current1 = current.current1 * multiplier1;\n    output.telemetry.Current2 = current.current2 * multiplier1;\n    output.telemetry.Current3 = current.current3 * multiplier1;\n    // output.telemetry.multiplier1 = multiplier1;\n  } else {\n    multiplier1 = parseBytesToInt(data.slice(7, 8));\n    var multiplier2 = parseBytesToInt(data.slice(12, 13));\n    var multiplier3 = parseBytesToInt(data.slice(13, 14));\n    output.telemetry.Current1 = current.current1 * multiplier1;\n    output.telemetry.Current2 = current.current2 * multiplier2;\n    output.telemetry.Current3 = current.current3 * multiplier3;\n    // output.telemetry.multiplier1 = multiplier1;\n    // output.telemetry.multiplier2 = multiplier2;\n    // output.telemetry.multiplier3 = multiplier3;\n  }\n}\n\nfunction reportDataCmdPort6Type3(data, output) {\n  var current = reportDataCmdPort6CurrentVolt(data, output);\n  var multiplier = multiplierByBit(data[7]);\n  multiplier.Current1 = current.current1;\n  multiplier.Current2 = current.current2;\n  multiplier.Current3 = current.current3;\n  // output.telemetry.multiplier = multiplier;\n  output.telemetry.Current1 = current.current1 * multiplier.multiplier1;\n  output.telemetry.Current2 = current.current2 * multiplier.multiplier2;\n  output.telemetry.Current3 = current.current3 * multiplier.multiplier3;\n  // output.telemetry.multiplier1 = multiplier.multiplier1;\n  // output.telemetry.multiplier2 = multiplier.multiplier2;\n  // output.telemetry.multiplier3 = multiplier.multiplier3;\n}\n\nfunction reportDataCmdPort6Type4(data, output) {\n  reportDataCmdPort6Volt(data[0], output);\n  var currentAlarm = parseByteToBinaryArray(data[1], 6, false);\n  // output.telemetry.dataAlarm = data[1];\n  // output.telemetry.Alarm = currentAlarm;\n  output.telemetry.LowCurrent1Alarm = currentAlarm[0];\n  output.telemetry.HighCurrent1Alarm = currentAlarm[1];\n  output.telemetry.LowCurrent2Alarm = currentAlarm[2];\n  output.telemetry.HighCurren2Alarm = currentAlarm[3];\n  output.telemetry.LowCurrent3Alarm = currentAlarm[4];\n  output.telemetry.HighCurrent3Alarm = currentAlarm[5];\n}\n\nfunction reportDataCmdPort6CurrentVolt(data, output) {\n  reportDataCmdPort6Volt(data[0], output);\n  var current = {};\n  current.current1 = parseBytesToInt(data.slice(1, 3));\n  current.current2 = parseBytesToInt(data.slice(3, 5));\n  current.current3 = parseBytesToInt(data.slice(5, 7));\n  return current;\n}\n\nfunction reportDataCmdPort6Volt(data, output) {\n  var volt = parseByteToBinaryArray(data);\n  var voltValue =  parseBinaryArrayToInt(volt, 1) * 0.1;\n  output.telemetry.Volt = voltValue;\n  if (volt[7] === 1) {\n    output.telemetry.LowVolt = true;\n  }\n}\n\nfunction multiplierByBit(data) {\n  var multiplier = {};\n  var binaryArray = parseByteToBinaryArray(data);\n  multiplier.multiplier1 = multiplierByBitValue(parseBinaryArrayToInt(binaryArray, 6, 2));\n  multiplier.multiplier2 = multiplierByBitValue(parseBinaryArrayToInt(binaryArray, 4, 2));\n  multiplier.multiplier3 = multiplierByBitValue(parseBinaryArrayToInt(binaryArray, 2, 2));\n  return multiplier;\n}\n\nfunction multiplierByBitValue(index) {\n  var results = [1, 5, 10, 100];\n  return results[index];\n}\n\n\n// --- attributes and telemetry objects ---\nvar telemetry = {};\nvar attributes = {};\n// --- attributes and telemetry objects ---\n\n// --- Timestamp parsing\nvar dateString = data.uplink_message.received_at;\n// If data is simulated or device doesn't send his own date string - we will use date from upcoming message, set by network server\nif ((data.simulated != null && data.simulated) || dateString == null) {\n  dateString = data.received_at;\n}\nvar timestamp = -1;\nif (dateString != null) {\n  timestamp = new Date(dateString).getTime();\n  if (timestamp == -1) {\n    var secondsSeparatorIndex = dateString.lastIndexOf('.') + 1;\n    var millisecondsEndIndex = dateString.lastIndexOf('+');\n    if (millisecondsEndIndex == -1) {\n      millisecondsEndIndex = dateString.lastIndexOf('Z');\n    }\n    if (millisecondsEndIndex == -1) {\n      millisecondsEndIndex = dateString.lastIndexOf('-');\n    }\n    if (millisecondsEndIndex == -1) {\n      if (dateString.length >= secondsSeparatorIndex + 3) {\n        dateString = dateString.substring(0, secondsSeparatorIndex + 3);\n      }\n    } else {\n      dateString = dateString.substring(0, secondsSeparatorIndex + 3) +\n          dateString.substring(millisecondsEndIndex, dateString.length);\n    }\n    timestamp = new Date(dateString).getTime();\n  }\n}\n// If we cannot parse timestamp - we will use the current timestamp\nif (timestamp == -1) {\n  timestamp = Date.now();\n}\n// --- Timestamp parsing\n\n// You can add some keys manually to attributes or telemetry\nattributes.devEui = data.end_device_ids.dev_eui;\nattributes.fPort = data.uplink_message.f_port;\n// We want to save correlation ids as single object, so we are excluding them from attributes parse and add manually\nattributes.correlation_ids = data.correlation_ids;\n\n// You can exclude some keys from the result\nvar excludeFromTelemetryList = [\"uplink_token\", \"gateway_id\", \"settings\", \"f_port\", \"time\", \"timestamp\", \"received_at\", \"network_ids\"];\nvar excludeFromAttributesList = [\"uplink_token\", \"gateway_id\", \"f_port\", \"time\", \"timestamp\", \"received_at\", \"session_key_id\", \"dev_eui\"];\n\n// Message parsing\n// To avoid paths in the decoded objects we passing false value to function as \"pathInKey\" argument.\n// Warning: pathInKey can cause already found fields to be overwritten with the last value found, e.g. receive_at from uplink_message will be written receive_at in the root.\nvar telemetryData = toFlatMap(data.uplink_message, excludeFromTelemetryList, false);\nvar attributesData = {};\nattributesData.putAll(toFlatMap(data.uplink_message.settings, excludeFromAttributesList, false));\nattributesData.putAll(toFlatMap(data.uplink_message.network_ids, excludeFromAttributesList, false));\nattributesData.putAll(toFlatMap(data.end_device_ids, excludeFromAttributesList, false));\n\n// Passing incoming bytes to decodeFrmPayload function, to get custom decoding\nvar customDecoding = {};\ncustomDecoding = decodeFrmPayload(data.uplink_message);\n\n// Collecting data to result\nif (customDecoding.?telemetry.size() > 0) {\n  telemetry.putAll(customDecoding.telemetry);\n}\n\nif (customDecoding.?attributes.size() > 0) {\n  attributes.putAll(customDecoding.attributes);\n}\n\ntelemetry.putAll(telemetryData);\nattributes.putAll(attributesData);\n\nvar result = {\n  deviceName: deviceName,\n  deviceType: deviceType,\n//  assetName: assetName,\n//  assetType: assetType,\n//  customerName: customerName,\n  groupName: groupName,\n  attributes: attributes,\n  telemetry: {\n    ts: timestamp,\n    values: telemetry\n  }\n};\n\nreturn result;",
    "encoder": null,
    "tbelEncoder": null,
    "updateOnlyKeys": [
      "devEui",
      "fPort",
      "bandwidth",
      "spreading_factor",
      "coding_rate",
      "frequency",
      "net_id",
      "tenant_id",
      "cluster_id",
      "cluster_address",
      "tenant_address",
      "device_id",
      "application_id",
      "join_eui",
      "dev_addr",
      "battery",
      "pir",
      "daylight",
      "eui",
      "forwarder_net_id",
      "forwarder_tenant_id",
      "forwarder_cluster_id",
      "forwarder_gateway_eui",
      "home_network_net_id",
      "home_network_tenant_id",
      "home_network_cluster_id"
    ]
  },
  "additionalInfo": {
    "description": ""
  },
  "edgeTemplate": false
}