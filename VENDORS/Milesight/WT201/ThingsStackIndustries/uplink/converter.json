{
    "name": "Milesight WT201 Uplink for ChirpStack integration",
    "type": "UPLINK",
    "debugMode": true,
    "configuration": {
        "scriptLang": "TBEL",
        "decoder": null,
        "tbelDecoder": "var data = decodeToJson(payload);\nvar deviceName = data.deviceInfo.deviceName;\nvar deviceType = data.deviceInfo.deviceProfileName;\nvar groupName = '9-in-1 IAQ Sensor';\n// var customerName = 'Customer A';\n// use assetName and assetType instead of deviceName and deviceType\n// to automatically create assets instead of devices.\n// var assetName = 'Asset A';\n// var assetType = 'building';\n\n// If you want to parse incoming data somehow, you can add your code to this function.\n// input: bytes\n// expected output:\n//  {\n//    \"attributes\": {\"attributeKey\": \"attributeValue\"},\n//    \"telemetry\": {\"telemetryKey\": \"telemetryValue\"}\n//  }\n//\n// In the example - bytes will be saved as HEX string and also parsed as light level, battery level and PIR sensor value.\n//\n\n// \"G\" Uplink; \"G/GH\" Downlink === \"g\"\n// \"CL&CN\" Downlink === \"cl_cn\"\nvar bitMaskWiringSettingss =[\n    {\"y1\": 0, \"g\": 2, \"ob\": 4, \"w1\": 6},\n    {\"e\": 0, \"cl_cn\": 2, \"pek\": 4, \"w2_aux\": 6},\n    {\"y2_gl\": 0, \"ob_mode\": 2}\n];\n\nfunction decodePayload(inputArray) {\n    var output = { attributes:{}, telemetry: {} };\n    // --- Decoding code --- //\n    var input = byteArrayToExecutionArrayList(inputArray);\n    output.telemetry.HEX_bytes = bytesToHex(input);\n\n    var historyData = {};\n    var decoded = {};\n    decoded.hexString = bytesToHex(input);\n\n    for (var i = 0; i < input.length - 2; ) {\n        var channel_id = input[i++] & 0xff;\n        var channel_type = input[i++] & 0xff;\n\n        //     // IPSO VERSION\n        if (channel_id === 0xFF && channel_type === 0x01) {\n            decoded.ipso_version = readProtocolVersion(input[i]);\n            i += 1;\n        }\n        // HARDWARE VERSION\n        else if (channel_id === 0xFF && channel_type === 0x09) {\n            decoded.hardware_version = readHardwareVersion(input.slice(i, i + 2));\n            i += 2;\n        }\n        // FIRMWARE VERSION\n        else if (channel_id === 0xFF && channel_type === 0x0A) {\n            decoded.firmware_version = readFirmwareVersion(input.slice(i, i + 2));\n            i += 2;\n        }\n        // DEVICE STATUS\n        else if (channel_id === 0xFF && channel_type === 0x0B) {\n            decoded.device_status = \"on\";\n            i += 1;\n        }\n        // LORAWAN CLASS TYPE\n        else if (channel_id === 0xFF && channel_type === 0x0F) {\n            decoded.lorawan_class = readLoRaWANClass(input[i] & 0xff);\n            i += 1;\n        }\n        // PRODUCT SERIAL NUMBER\n        else if (channel_id === 0xFF && channel_type === 0x16) {\n            decoded.sn = readSerialNumber(input.slice(i, i+ 8));\n            i += 8;\n        }\n        // TSL VERSION\n        else if (channel_id === 0xFF && channel_type === 0xFF) {\n            decoded.tsl_version = readFirmwareVersion(input.slice(i, i + 2));\n            i += 2;\n        }\n        // TEMPERATURE\n        else if (channel_id === 0x03 && channel_type === 0x67) {\n            decoded.temperature = parseBytesIntToFloat(input, i, 2, false) / 10;\n            i += 2;\n        }\n        // TEMPERATURE TARGET\n        else if (channel_id === 0x04 && channel_type === 0x67) {\n            decoded.temperature_target = parseBytesIntToFloat(input, i, 2, false) / 10;\n            i += 2;\n        }\n        // TEMPERATURE CONTROL\n        else if (channel_id === 0x05 && channel_type === 0xE7) {\n            var temperature_control = input[i];\n            decoded.temperature_control_mode = readTemperatureCtlMode(temperature_control & 0x03);\n            decoded.temperature_control_status = readTemperatureCtlStatus((temperature_control >>> 4) & 0x0f);\n            i += 1;\n        }\n        // FAN CONTROL\n        else if (channel_id === 0x06 && channel_type === 0xE8) {\n            var valueFanControl = input[i];\n            decoded.fan_mode = readFanMode(valueFanControl & 0x03);\n            decoded.fan_status = readFanStatus((valueFanControl >>> 2) & 0x03);\n            i += 1;\n        }\n        // PLAN EVENT\n        else if (channel_id === 0x07 && channel_type === 0xBC) {\n            decoded.plan_event = readPlanEvent(input[i] & 0x0f);\n            i += 1;\n        }\n        // SYSTEM STATUS\n        else if (channel_id === 0x08 && channel_type === 0x8E) {\n            decoded.system_status = readSystemStatus(input[i] & 0xff);\n            i += 1;\n        }\n        // HUMIDITY\n        else if (channel_id === 0x09 && channel_type === 0x68) {\n            decoded.humidity = parseBytesIntToFloat(input, i, 1) / 2;\n            i += 1;\n        }\n        // RELAY STATUS\n        else if (channel_id === 0x0A && channel_type === 0x6E) {\n            decoded.wires_relay = readWiresRelay(input[i] & 0xff);\n            i += 1;\n        }\n        // PLAN\n        else if (channel_id === 0xFF && channel_type === 0xC9) {\n            var schedule = {};\n            schedule.type = readPlanType(input[i]);\n            schedule.index = (input[i + 1] & 0xff) + 1;\n            schedule.plan_enable = input[i + 2] === 0 ? \"disable\" : \"enable\";\n            schedule.week_recycle = readWeekRecycleSettings(input[i + 3] & 0xff);\n            var time_mins = parseBytesToInt(input, i + 4, 2, false);\n            schedule.time = String.format(\"%02d:%02d\", (int) (time_mins / 60), time_mins % 60);\n            i += 6;\n\n            if (decoded.plan_schedule === null) {\n                decoded.plan_schedule = [];\n            }\n            schedule.i = i ;\n            decoded.plan_schedule.push(schedule);\n        }\n        // PLAN SETTINGS\n        else if (channel_id === 0xFF && channel_type === 0xC8) {\n            var plan_setting = {};\n            plan_setting.type = readPlanType(input[i] & 0xff);\n            plan_setting.temperature_ctl_mode = readTemperatureCtlMode(input[i + 1] & 0xff);\n            plan_setting.fan_mode = readFanMode(input[i + 2] & 0xff);\n            plan_setting.temperature_target = input[i + 3] & 0x7f;\n            plan_setting.temperature_unit = readTemperatureUnit(input[i + 3] >>> 7);\n            plan_setting.temperature_error = parseBytesIntToFloat(input, i + 4, 1, false) / 10;\n            i += 5;\n\n            if (decoded.plan_settings === null) {\n                decoded.plan_settings = [];\n            }\n            decoded.plan_settings.push(plan_setting);\n        }\n        // WIRES\n        else if (channel_id === 0xFF && channel_type === 0xCA) {\n            decoded.wires = readWires([input[i] & 0xff, input[i + 1] & 0xff, input[i + 2] & 0xff]);\n            decoded.ob_mode = readObMode((input[i + 2] >>> 2) & 0x03);\n            i += 3;\n        }\n        // TEMPERATURE MODE SUPPORT\n        else if (channel_id === 0xFF && channel_type === 0xCB) {\n            decoded.temperature_control_mode_enable = readTemperatureCtlModeEnable(input[i] & 0xff);\n            decoded.temperature_control_status_enable = readTemperatureCtlStatusEnable(input[i + 1] & 0xff, input[i + 2] & 0xff);\n            i += 3;\n        }\n        // CONTROL PERMISSIONS\n        else if (channel_id === 0xFF && channel_type === 0xF6) {\n            decoded.control_permissions = input[i] === 1 ? \"remote control\" : \"thermostat\";\n            i += 1;\n        }\n        // TEMPERATURE ALARM\n        else if (channel_id === 0x83 && channel_type === 0x67) {\n            decoded.temperature = parseBytesToInt(input, i, 2, false) / 10;\n            decoded.temperature_alarm = readTemperatureAlarm(input[i + 2] & 0xff);\n            i += 2;\n        }\n        // TEMPERATURE EXCEPTION\n        else if (channel_id === 0xB3 && channel_type === 0x67) {\n            decoded.temperature_exception = readException(input[i]);\n            i += 1;\n        }\n        // HUMIDITY EXCEPTION\n        else if (channel_id === 0xB9 && channel_type === 0x68) {\n            decoded.humidity_exception = readException(input[i] & 0xff);\n            i += 1;\n        }\n        // HISTORICAL DATA\n        else if (channel_id === 0x20 && channel_type === 0xce) {\n            var timestamp = parseBytesToInt(input, i, 4, false);\n            var value1 = parseBytesToInt(input, i+4, 2, false);\n            var value2 = parseBytesToInt(input, i+6, 2, false);\n            var data = {};\n            data.timestamp = timestamp;\n\n            // fan_mode(0..1) + fan_status(2..3) + system_status(4) + temperature(5..15)\n            data.fan_mode = readFanMode(value1 & 0x03);\n            data.fan_status = readFanStatus((value1 >>> 2) & 0x03);\n            data.system_status = readSystemStatus((value1 >>> 4) & 0x01);\n\n            // temperature_ctl_mode(0..1) + temperature_ctl_status(2..4) + temperature_target(5..15)\n            var temperature = 1.0 * ((value1 >>> 5) & 0x7ff) / 10 - 100;\n            data.temperature = toFixed(temperature, 1);\n            data.temperature_ctl_mode = readTemperatureCtlMode(value2 & 0x03);\n            data.temperature_ctl_status = readTemperatureCtlStatus((value2 >>> 2) & 0x07);\n            var temperature_target =  1.0 * ((value2 >>> 5) & 0x7ff) / 10 - 100;\n            data.temperature_target = toFixed(temperature_target, 1);\n            i += 8;\n\n            decoded.history = [];\n            decoded.history.push(data);\n        }\n    }\n\n    output.telemetry = decoded;\n\n    // --- Decoding code --- //\n    return output;\n}\n\nfunction readProtocolVersion(bytes) {\n    var minor = (bytes & 0xf0) >> 4;\n    var major = bytes & 0x0f;\n    return \"v\" + major + \".\" + minor;\n}\n\nfunction readHardwareVersion(bytes) {\n    var major = bytes[0] & 0xff;\n    var minor = (bytes[1] & 0xff) >> 4;\n    return \"v\" + major + \".\" + minor;\n}\n\nfunction readFirmwareVersion(bytes) {\n    var major = bytes[0] & 0xff;\n    var minor = bytes[1] & 0xff;\n    return \"v\" + major + \".\" + minor;\n}\n\nfunction readSerialNumber(bytes) {\n    return bytesToHex(bytes);\n}\n\nfunction readLoRaWANClass(type) {\n    switch (type) {\n        case 0x00:\n            return \"ClassA\";\n        case 0x01:\n            return \"ClassB\";\n        case 0x02:\n            return \"ClassC\";\n        case 0x03:\n            return \"ClassCtoB\";\n        default:\n            return \"unknown\";\n    }\n}\n\nfunction readTemperatureUnit(type) {\n    switch (type) {\n        case 0x00:\n            return \"℃\";\n        case 0x01:\n            return \"℉\";\n        default:\n            return \"unknown\";\n    }\n}\n\nfunction readTemperatureAlarm(type) {\n    switch (type) {\n        case 0x01:\n            return \"emergency heating timeout alarm\";\n        case 0x02:\n            return \"auxiliary heating timeout alarm\";\n        case 0x03:\n            return \"persistent low temperature alarm\";\n        case 0x04:\n            return \"persistent low temperature alarm release\";\n        case 0x05:\n            return \"persistent high temperature alarm\";\n        case 0x06:\n            return \"persistent high temperature alarm release\";\n        case 0x07:\n            return \"freeze protection alarm\";\n        case 0x08:\n            return \"freeze protection alarm release\";\n        case 0x09:\n            return \"temperature threshold alarm\";\n        case 0x0a:\n            return \"temperature threshold alarm release\";\n        default:\n    }\n}\n\nfunction readException(type) {\n    switch (type) {\n        case 0x01:\n            return \"collection failure\";\n        case 0x02:\n            return \"out of measuring range\";\n        default:\n    }\n}\n\nfunction readPlanEvent(type) {\n    switch (type) {\n        case 0x00:\n            return \"not executed\";\n        case 0x01:\n            return \"wake\";\n        case 0x02:\n            return \"away\";\n        case 0x03:\n            return \"home\";\n        case 0x04:\n            return \"sleep\";\n        default:\n    }\n}\n\nfunction readPlanType(type) {\n    switch (type) {\n        case 0x00:\n            return \"wake\";\n        case 0x01:\n            return \"away\";\n        case 0x02:\n            return \"home\";\n        case 0x03:\n            return \"sleep\";\n        default:\n    }\n}\n\nfunction readFanMode(type) {\n    switch (type) {\n        case 0x00:\n            return \"auto\";\n        case 0x01:\n            return \"on\";\n        case 0x02:\n            return \"circulate\";\n        default:\n    }\n}\n\nfunction readFanStatus(type) {\n    switch (type) {\n        case 0x00:\n            return \"off\";\n        case 0x01:\n            return \"high speed\";\n        case 0x02:\n            return \"low speed\";\n        case 0x03:\n            return \"on\";\n        default:\n    }\n}\n\nfunction readSystemStatus(type) {\n    switch (type) {\n        case 0x00:\n            return \"off\";\n        case 0x01:\n            return \"on\";\n        default:\n    }\n}\n\nfunction readTemperatureCtlMode(type) {\n    switch (type) {\n        case 0x00:\n            return \"heat\";\n        case 0x01:\n            return \"em heat\";\n        case 0x02:\n            return \"cool\";\n        case 0x03:\n            return \"auto\";\n        default:\n    }\n}\n\nfunction readTemperatureCtlStatus(type) {\n    switch (type) {\n        case 0x00:\n            return \"standby\";\n        case 0x01:\n            return \"stage-1 heat\";\n        case 0x02:\n            return \"stage-2 heat\";\n        case 0x03:\n            return \"stage-3 heat\";\n        case 0x04:\n            return \"stage-4 heat\";\n        case 0x05:\n            return \"em heat\";\n        case 0x06:\n            return \"stage-1 cool\";\n        case 0x07:\n            return \"stage-2 cool\";\n        default:\n    }\n}\n\nfunction readWires(wireArrays) {\n    var wire = [];\n    for (var i = 0; i < 3; i++) {\n        var wireArray = wireArrays[i];\n        var bitMaskWiringSettings = bitMaskWiringSettingss[i];\n        foreach(bitMaskWiringSetting : bitMaskWiringSettings.entrySet()) {\n            var wireArrayValue = ((wireArray >>> bitMaskWiringSetting.value) & 0x03);\n            if (bitMaskWiringSetting.key != \"ob_mode\" && wireArrayValue != 0) {\n                if (i === 1 && bitMaskWiringSetting.key === \"w2_aux\") {\n                    switch (wireArrayValue) {\n                        case 1:\n                            wire.push(\"w2\");\n                            break;\n                        case 2:\n                            wire.push(\"aux\");\n                            break;\n                        default:\n                    }\n                } else if (i === 2 && bitMaskWiringSetting.key === \"y2_gl\") {\n                    switch (wireArrayValue) {\n                        case 1:\n                            wire.push(\"y2\");\n                            break;\n                        case 2:\n                            wire.push(\"gl\");\n                            break;\n                        default:\n                    }\n                } else {\n                    wire.push(bitMaskWiringSetting.key);\n                }\n            }\n        }\n    }\n    return wire;\n}\n\nfunction readWiresRelay(status) {\n    var relay = {};\n    var statusBinaryArray =  parseByteToBinaryArray(status, 7, false);\n    relay.y1 = statusBinaryArray[0];\n    relay.y2_gl = statusBinaryArray[1];\n    relay.w1 = statusBinaryArray[2];\n    relay.w2_aux = statusBinaryArray[3];\n    relay.e = statusBinaryArray[4];\n    relay.g = statusBinaryArray[5];\n    relay.ob = statusBinaryArray[6];\n    return relay;\n}\n\nfunction readObMode(type) {\n    switch (type) {\n        case 0x00:      // 00\n            return \"cool\";\n        case 0x01:      // 01\n            return \"heat\";\n        case 0x03:      // 11\n            return \"Keep Original Setting\";\n        default:\n    }\n}\n\nfunction readTemperatureCtlModeEnable(type) {\n    // bit0: heat, bit1: em heat, bit2: cool, bit3: auto\n    var enable = [];\n    if (((type >>> 0) & 0x01) !=0) {\n        enable.push(\"heat\");\n    }\n    if (((type >>> 1) & 0x01) !=0) {\n        enable.push(\"em heat\");\n    }\n    if (((type >>> 2) & 0x01) !=0) {\n        enable.push(\"cool\");\n    }\n    if (((type >>> 3) & 0x01) !=0) {\n        enable.push(\"auto\");\n    }\n    return enable;\n}\n\nfunction readTemperatureCtlStatusEnable(heat_mode, cool_mode) {\n    // bit0: stage-1 heat, bit1: stage-2 heat, bit2: stage-3 heat, bit3: stage-4 heat, bit4: aux heat\n    var enable = [];\n    if (((heat_mode >>> 0) & 0x01) !=0) {\n        enable.push(\"stage-1 heat\");\n    }\n    if (((heat_mode >>> 1) & 0x01) !=0) {\n        enable.push(\"stage-2 heat\");\n    }\n    if (((heat_mode >>> 2) & 0x01) !=0) {\n        enable.push(\"stage-3 heat\");\n    }\n    if (((heat_mode >>> 3) & 0x01) !=0) {\n        enable.push(\"stage-4 heat\");\n    }\n    if (((heat_mode >>> 4) & 0x01) !=0) {\n        enable.push(\"aux heat\");\n    }\n\n    // bit0: stage-1 cool, bit1: stage-2 cool\n    if (((cool_mode >>> 0) & 0x03) !=0) {\n        enable.push(\"stage-1 cool\");\n    }\n    if (((cool_mode >>> 1) & 0x03) !=0) {\n        enable.push(\"stage-2 cool\");\n    }\n    return enable;\n}\n\nfunction readWeekRecycleSettings(type) {\n    // bit1: \"mon\", bit2: \"tues\", bit3: \"wed\", bit4: \"thur\", bit5: \"fri\", bit6: \"sat\", bit7: \"sun\"\n    var week_enable = [];\n    if (((type >>> 1) & 0x01) != 0){\n        week_enable.push(\"Mon.\");\n    }\n    if (((type >>> 2) & 0x01) != 0){\n        week_enable.push(\"Tues.\");\n    }\n    if (((type >>> 3) & 0x01) != 0){\n        week_enable.push(\"Wed.\");\n    }\n    if (((type >>> 4) & 0x01) != 0){\n        week_enable.push(\"Thur.\");\n    }\n    if (((type >>> 5) & 0x01) != 0){\n        week_enable.push(\"Fri.\");\n    }\n    if (((type >>> 6) & 0x01) != 0){\n        week_enable.push(\"Sat.\");\n    }\n    if (((type >>> 7) & 0x01) != 0){\n        week_enable.push(\"Sun.\");\n    }\n    return week_enable;\n}\n\n// --- attributes and telemetry objects ---\nvar telemetry = {};\nvar attributes = {};\n// --- attributes and telemetry objects ---\n\n// --- Timestamp parsing\nvar dateString = data.time;\nvar timestamp = -1;\nif (dateString != null) {\n    timestamp = new Date(dateString).getTime();\n    if (timestamp == -1) {\n        var secondsSeparatorIndex = dateString.lastIndexOf('.') + 1;\n        var millisecondsEndIndex = dateString.lastIndexOf('+');\n        if (millisecondsEndIndex == -1) {\n            millisecondsEndIndex = dateString.lastIndexOf('Z');\n        }\n        if (millisecondsEndIndex == -1) {\n            millisecondsEndIndex = dateString.lastIndexOf('-');\n        }\n        if (millisecondsEndIndex == -1) {\n            if (dateString.length >= secondsSeparatorIndex + 3) {\n                dateString = dateString.substring(0, secondsSeparatorIndex + 3);\n            }\n        } else {\n            dateString = dateString.substring(0, secondsSeparatorIndex + 3) +\n                dateString.substring(millisecondsEndIndex, dateString.length);\n        }\n        timestamp = new Date(dateString).getTime();\n    }\n}\n// If we cannot parse timestamp - we will use the current timestamp\nif (timestamp == -1) {\n    timestamp = Date.now();\n}\n// --- Timestamp parsing\n\n// You can add some keys manually to attributes or telemetry\nattributes.deduplicationId = data.deduplicationId;\n\n// You can exclude some keys from the result\nvar excludeFromAttributesList = [\"deviceName\", \"rxInfo\", \"confirmed\", \"data\", \"deduplicationId\",\"time\", \"adr\", \"dr\", \"fCnt\"];\nvar excludeFromTelemetryList = [\"data\", \"deviceInfo\", \"txInfo\", \"devAddr\", \"adr\", \"time\", \"fPort\", \"region_common_name\", \"region_config_id\", \"deduplicationId\"];\n\n// Message parsing\n// To avoid paths in the decoded objects we passing false value to function as \"pathInKey\" argument.\n// Warning: pathInKey can cause already found fields to be overwritten with the last value found.\n\nvar telemetryData = toFlatMap(data, excludeFromTelemetryList, false);\nvar attributesData = toFlatMap(data, excludeFromAttributesList, false);\n\nvar uplinkDataList = [];\n\n// Passing incoming bytes to decodePayload function, to get custom decoding\nvar customDecoding = decodePayload(base64ToBytes(data.data));\n\n// Collecting data to result\nif (customDecoding.?telemetry.size() > 0) {\n    telemetry.putAll(customDecoding.telemetry);\n}\n\nif (customDecoding.?attributes.size() > 0) {\n    attributes.putAll(customDecoding.attributes);\n}\n\ntelemetry.putAll(telemetryData);\nattributes.putAll(attributesData);\n\nvar result = {\n    deviceName: deviceName,\n    deviceType: deviceType,\n//  assetName: assetName,\n//  assetType: assetType,\n//  customerName: customerName,\n    groupName: groupName,\n    attributes: attributes,\n    telemetry: {\n        ts: timestamp,\n        values: telemetry\n    }\n};\n\nreturn result;",
        "encoder": null,
        "tbelEncoder": null,
        "updateOnlyKeys": [
            "tenantId",
            "tenantName",
            "applicationId",
            "applicationName",
            "deviceProfileId",
            "deviceProfileName",
            "devEui",
            "devAddr",
            "fPort",
            "frequency",
            "bandwidth",
            "spreadingFactor",
            "codeRate",
            "battery",
            "pir",
            "daylight",
            "confirmed",
            "gatewayId",
            "channel",
            "rfChain",
            "crcStatus"
        ]
    },
    "additionalInfo": {
        "description": ""
    },
    "edgeTemplate": false
}